/* tslint:disable */
/* eslint-disable */
/**
 * Geocoding OSM
 * With the Geocoding OSM service places can be searched based on OSM data. The search is based on an address, text input or a geographical position.
 *
 * The version of the OpenAPI document: 1.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from '../runtime';
import type { BoundingBox } from './BoundingBox';
import {
    BoundingBoxFromJSON,
    BoundingBoxFromJSONTyped,
    BoundingBoxToJSON,
} from './BoundingBox';
import type { ReferencePosition } from './ReferencePosition';
import {
    ReferencePositionFromJSON,
    ReferencePositionFromJSONTyped,
    ReferencePositionToJSON,
} from './ReferencePosition';

/**
 * 
 * @export
 * @interface Place
 */
export interface Place {
    /**
     * 
     * @type {ReferencePosition}
     * @memberof Place
     */
    referencePosition: ReferencePosition;
    /**
     * 
     * @type {BoundingBox}
     * @memberof Place
     */
    boundingBox?: BoundingBox;
    /**
     * A single string containing the name and all address elements of a place.
     * @type {string}
     * @memberof Place
     */
    formattedAddress: string;
    /**
     * The category of this place, which corresponds to the key of the main OSM tag.
     * @type {string}
     * @memberof Place
     */
    category: string;
    /**
     * The type of this place, which corresponds to the value of the main OSM tag. Each category is divided into different types.
     * @type {string}
     * @memberof Place
     */
    type: string;
}

/**
 * Check if a given object implements the Place interface.
 */
export function instanceOfPlace(value: object): value is Place {
    if (!('referencePosition' in value) || value['referencePosition'] === undefined) return false;
    if (!('formattedAddress' in value) || value['formattedAddress'] === undefined) return false;
    if (!('category' in value) || value['category'] === undefined) return false;
    if (!('type' in value) || value['type'] === undefined) return false;
    return true;
}

export function PlaceFromJSON(json: any): Place {
    return PlaceFromJSONTyped(json, false);
}

export function PlaceFromJSONTyped(json: any, ignoreDiscriminator: boolean): Place {
    if (json == null) {
        return json;
    }
    return {
        
        'referencePosition': ReferencePositionFromJSON(json['referencePosition']),
        'boundingBox': json['boundingBox'] == null ? undefined : BoundingBoxFromJSON(json['boundingBox']),
        'formattedAddress': json['formattedAddress'],
        'category': json['category'],
        'type': json['type'],
    };
}

export function PlaceToJSON(value?: Place | null): any {
    if (value == null) {
        return value;
    }
    return {
        
        'referencePosition': ReferencePositionToJSON(value['referencePosition']),
        'boundingBox': BoundingBoxToJSON(value['boundingBox']),
        'formattedAddress': value['formattedAddress'],
        'category': value['category'],
        'type': value['type'],
    };
}

