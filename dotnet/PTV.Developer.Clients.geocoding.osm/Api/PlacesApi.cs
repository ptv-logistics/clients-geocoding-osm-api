/*
 * Geocoding OSM
 *
 * With the Geocoding OSM service places can be searched based on OSM data. The search is based on an address, text input or a geographical position.
 *
 * The version of the OpenAPI document: 1.1
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using PTV.Developer.Clients.geocoding.osm.Client;
using PTV.Developer.Clients.geocoding.osm.Model;

namespace PTV.Developer.Clients.geocoding.osm.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPlacesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a multi-field address input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        PlacesSearchResult SearchPlacesByAddress(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a multi-field address input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        ApiResponse<PlacesSearchResult> SearchPlacesByAddressWithHttpInfo(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        PlacesSearchResult SearchPlacesByPosition(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        ApiResponse<PlacesSearchResult> SearchPlacesByPositionWithHttpInfo(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a single-field text input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        PlacesSearchResult SearchPlacesByText(string searchText, List<string> languages = default(List<string>), int operationIndex = 0);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a single-field text input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        ApiResponse<PlacesSearchResult> SearchPlacesByTextWithHttpInfo(string searchText, List<string> languages = default(List<string>), int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPlacesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a multi-field address input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByAddressAsync(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a multi-field address input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<PlacesSearchResult>> SearchPlacesByAddressWithHttpInfoAsync(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByPositionAsync(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places near a given geographical position.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<PlacesSearchResult>> SearchPlacesByPositionWithHttpInfoAsync(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a single-field text input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByTextAsync(string searchText, List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Searches for places based on a single-field text input.
        /// </remarks>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<PlacesSearchResult>> SearchPlacesByTextWithHttpInfoAsync(string searchText, List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IPlacesApi : IPlacesApiSync, IPlacesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class PlacesApi : IPlacesApi
    {
        private PTV.Developer.Clients.geocoding.osm.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PlacesApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PlacesApi(string basePath)
        {
            this.Configuration = PTV.Developer.Clients.geocoding.osm.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.geocoding.osm.Client.GlobalConfiguration.Instance,
                new PTV.Developer.Clients.geocoding.osm.Client.Configuration { BasePath = basePath }
            );
            this.Client = new PTV.Developer.Clients.geocoding.osm.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.geocoding.osm.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = PTV.Developer.Clients.geocoding.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PlacesApi(PTV.Developer.Clients.geocoding.osm.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = PTV.Developer.Clients.geocoding.osm.Client.Configuration.MergeConfigurations(
                PTV.Developer.Clients.geocoding.osm.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new PTV.Developer.Clients.geocoding.osm.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new PTV.Developer.Clients.geocoding.osm.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = PTV.Developer.Clients.geocoding.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlacesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public PlacesApi(PTV.Developer.Clients.geocoding.osm.Client.ISynchronousClient client, PTV.Developer.Clients.geocoding.osm.Client.IAsynchronousClient asyncClient, PTV.Developer.Clients.geocoding.osm.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = PTV.Developer.Clients.geocoding.osm.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public PTV.Developer.Clients.geocoding.osm.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public PTV.Developer.Clients.geocoding.osm.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public PTV.Developer.Clients.geocoding.osm.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public PTV.Developer.Clients.geocoding.osm.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        ///  Searches for places based on a multi-field address input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        public PlacesSearchResult SearchPlacesByAddress(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0)
        {
            PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> localVarResponse = SearchPlacesByAddressWithHttpInfo(country, state, province, locality, postalCode, street, houseNumber, languages);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Searches for places based on a multi-field address input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        public PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> SearchPlacesByAddressWithHttpInfo(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0)
        {
            PTV.Developer.Clients.geocoding.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.geocoding.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (country != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "country", country));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (province != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "province", province));
            }
            if (locality != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "locality", locality));
            }
            if (postalCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "postalCode", postalCode));
            }
            if (street != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "street", street));
            }
            if (houseNumber != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "houseNumber", houseNumber));
            }
            if (languages != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("csv", "languages", languages));
            }

            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByAddress";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PlacesSearchResult>("/places/by-address", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Searches for places based on a multi-field address input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        public async System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByAddressAsync(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> localVarResponse = await SearchPlacesByAddressWithHttpInfoAsync(country, state, province, locality, postalCode, street, houseNumber, languages, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Searches for places based on a multi-field address input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="country">The country in which the places should be searched. A country may be defined by name or ISO code (ISO 3166-1 alpha-2). (optional)</param>
        /// <param name="state">A subdivision of a country, for example a state or a region. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="province">A subdivision of a state, for example the province or county. Using this field narrows down the search and reduces the number of possible results. (optional)</param>
        /// <param name="locality">The locality of the address, which may be a city, a district or subdistrict. (optional)</param>
        /// <param name="postalCode">The postal code, or zip-code, which is used by a postal authority of a country to identify where the address is located. (optional)</param>
        /// <param name="street">The name of the road where the address is located. It may contain a house number, but using the **houseNumber** field instead will lead to better results. (optional)</param>
        /// <param name="houseNumber">The house number of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult>> SearchPlacesByAddressWithHttpInfoAsync(string country = default(string), string state = default(string), string province = default(string), string locality = default(string), string postalCode = default(string), string street = default(string), string houseNumber = default(string), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {

            PTV.Developer.Clients.geocoding.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.geocoding.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (country != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "country", country));
            }
            if (state != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "state", state));
            }
            if (province != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "province", province));
            }
            if (locality != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "locality", locality));
            }
            if (postalCode != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "postalCode", postalCode));
            }
            if (street != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "street", street));
            }
            if (houseNumber != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "houseNumber", houseNumber));
            }
            if (languages != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("csv", "languages", languages));
            }

            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByAddress";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PlacesSearchResult>("/places/by-address", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByAddress", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        public PlacesSearchResult SearchPlacesByPosition(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0)
        {
            PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> localVarResponse = SearchPlacesByPositionWithHttpInfo(latitude, longitude, detailLevel, languages);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        public PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> SearchPlacesByPositionWithHttpInfo(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0)
        {
            // verify the required parameter 'latitude' is set
            if (latitude == null)
            {
                throw new PTV.Developer.Clients.geocoding.osm.Client.ApiException(400, "Missing required parameter 'latitude' when calling PlacesApi->SearchPlacesByPosition");
            }

            // verify the required parameter 'longitude' is set
            if (longitude == null)
            {
                throw new PTV.Developer.Clients.geocoding.osm.Client.ApiException(400, "Missing required parameter 'longitude' when calling PlacesApi->SearchPlacesByPosition");
            }

            PTV.Developer.Clients.geocoding.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.geocoding.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("latitude", PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (detailLevel != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "detailLevel", detailLevel));
            }
            if (languages != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("csv", "languages", languages));
            }

            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByPosition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PlacesSearchResult>("/places/by-position/{latitude}/{longitude}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        public async System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByPositionAsync(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> localVarResponse = await SearchPlacesByPositionWithHttpInfoAsync(latitude, longitude, detailLevel, languages, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Searches for places near a given geographical position.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="latitude"></param>
        /// <param name="longitude"></param>
        /// <param name="detailLevel">Detail level of the address. (optional)</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult>> SearchPlacesByPositionWithHttpInfoAsync(double? latitude, double? longitude, DetailLevel? detailLevel = default(DetailLevel?), List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'latitude' is set
            if (latitude == null)
            {
                throw new PTV.Developer.Clients.geocoding.osm.Client.ApiException(400, "Missing required parameter 'latitude' when calling PlacesApi->SearchPlacesByPosition");
            }

            // verify the required parameter 'longitude' is set
            if (longitude == null)
            {
                throw new PTV.Developer.Clients.geocoding.osm.Client.ApiException(400, "Missing required parameter 'longitude' when calling PlacesApi->SearchPlacesByPosition");
            }


            PTV.Developer.Clients.geocoding.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.geocoding.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("latitude", PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToString(latitude)); // path parameter
            localVarRequestOptions.PathParameters.Add("longitude", PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToString(longitude)); // path parameter
            if (detailLevel != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "detailLevel", detailLevel));
            }
            if (languages != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("csv", "languages", languages));
            }

            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByPosition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PlacesSearchResult>("/places/by-position/{latitude}/{longitude}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByPosition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Searches for places based on a single-field text input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PlacesSearchResult</returns>
        public PlacesSearchResult SearchPlacesByText(string searchText, List<string> languages = default(List<string>), int operationIndex = 0)
        {
            PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> localVarResponse = SearchPlacesByTextWithHttpInfo(searchText, languages);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Searches for places based on a single-field text input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PlacesSearchResult</returns>
        public PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> SearchPlacesByTextWithHttpInfo(string searchText, List<string> languages = default(List<string>), int operationIndex = 0)
        {
            // verify the required parameter 'searchText' is set
            if (searchText == null)
            {
                throw new PTV.Developer.Clients.geocoding.osm.Client.ApiException(400, "Missing required parameter 'searchText' when calling PlacesApi->SearchPlacesByText");
            }

            PTV.Developer.Clients.geocoding.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.geocoding.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "searchText", searchText));
            if (languages != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("csv", "languages", languages));
            }

            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByText";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PlacesSearchResult>("/places/by-text", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByText", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        ///  Searches for places based on a single-field text input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PlacesSearchResult</returns>
        public async System.Threading.Tasks.Task<PlacesSearchResult> SearchPlacesByTextAsync(string searchText, List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult> localVarResponse = await SearchPlacesByTextWithHttpInfoAsync(searchText, languages, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        ///  Searches for places based on a single-field text input.
        /// </summary>
        /// <exception cref="PTV.Developer.Clients.geocoding.osm.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchText">Free-form text input that describes a place.</param>
        /// <param name="languages">A comma-separated list of preferred languages for the response, formatted according to [ISO-639-1](https://www.loc.gov/standards/iso639-2/php/code_list.php) for languages or [BCP47](https://tools.ietf.org/html/bcp47) for language variants. These languages are ordered by decreasing priority. In case none of the given preferred languages is available in the data, the default language is used, which is the language spoken in the country or region of the result (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PlacesSearchResult)</returns>
        public async System.Threading.Tasks.Task<PTV.Developer.Clients.geocoding.osm.Client.ApiResponse<PlacesSearchResult>> SearchPlacesByTextWithHttpInfoAsync(string searchText, List<string> languages = default(List<string>), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
        {
            // verify the required parameter 'searchText' is set
            if (searchText == null)
            {
                throw new PTV.Developer.Clients.geocoding.osm.Client.ApiException(400, "Missing required parameter 'searchText' when calling PlacesApi->SearchPlacesByText");
            }


            PTV.Developer.Clients.geocoding.osm.Client.RequestOptions localVarRequestOptions = new PTV.Developer.Clients.geocoding.osm.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("", "searchText", searchText));
            if (languages != null)
            {
                localVarRequestOptions.QueryParameters.Add(PTV.Developer.Clients.geocoding.osm.Client.ClientUtils.ParameterToMultiMap("csv", "languages", languages));
            }

            localVarRequestOptions.Operation = "PlacesApi.SearchPlacesByText";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (apiKeyAuth) required
            if (!string.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apiKey")))
            {
                localVarRequestOptions.HeaderParameters.Add("apiKey", this.Configuration.GetApiKeyWithPrefix("apiKey"));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PlacesSearchResult>("/places/by-text", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("SearchPlacesByText", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
